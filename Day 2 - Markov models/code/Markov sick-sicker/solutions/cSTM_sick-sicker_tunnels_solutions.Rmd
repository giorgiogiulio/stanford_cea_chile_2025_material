---
title: 'SOLUTIONS - cSTM Sick-Sicker model in R - Excerise'
subtitle: 'With state-residence time dependence'
author: "The DARTH workgroup"
output:
  html_document: default
  pdf_document: default
---

This code forms the basis for the state-transition model of the tutorial: 
'A Tutorial on Time-Dependent Cohort State-Transition Models in R using a Cost-Effectiveness Analysis Example' 
Medical Decision Making. 2023;43(1):21-41. doi:10.1177/0272989X221121747

Authors: 
- Fernando Alarid-Escudero 
- Eline Krijkamp
- Eva A. Enns
- Alan Yang
- M.G. Myriam Hunink
- Petros Pechlivanoglou
- Hawre Jalal
Please cite the article when using this code

To program this tutorial we used:
R version 4.0.5 (2021-03-31)
Platform: 64-bit operating system, x64-based processor
Running under: Mac OS 12.2.1
RStudio: Version 1.4.1717 2009-2021 RStudio, Inc

This code implements a state-residence time-dependent Sick-Sicker cSTM model to conduct a CEA of two strategies:
- Standard of Care (SoC): best available care for the patients with the  disease. This scenario reflects the natural history of the disease 
  progression.
- Strategy AB: This strategy combines treatment A and treatment B. The disease progression is reduced, and individuals in the Sick state have an 
  improved quality of life.

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = T)
```

Change `eval` to `TRUE` if you want to knit this document.

```{r}
rm(list = ls())      # clear memory (removes all the variables from the workspace)
```

# 01 Load packages

```{r, warning = F, message = F}
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("dplyr", "tidyr", "reshape2", "devtools", "scales", "ellipse", "ggplot2", "ggrepel", "gridExtra", "lazyeval", "igraph", "truncnorm", "ggraph", "reshape2", "patchwork", "knitr", "stringr", "MethylCapSig", "diagram", "dampack")                                               
# load (install if required) packages from GitHub
# install_github("DARTH-git/darthtools", force = TRUE) #Uncomment if there is a newer version
p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
# all functions are in the darthtools package
```

# 03 Model input

```{r}
## General setup 
cycle_length <- 1   # cycle length equal to one year (use 1/12 for monthly)
n_age_init   <- 25  # age at baseline
n_age_max    <- 100 # maximum age of follow up
n_cycles     <- (n_age_max - n_age_init)/cycle_length # time horizon, number of cycles
# Age labels 
v_age_names  <- paste(rep(n_age_init:(n_age_max - 1), each = 1/cycle_length), 
                      1:(1/cycle_length), 
                      sep = ".")
# the 4 health states of the model:
v_names_states <- c("H",  # Healthy (H)
                    "S1", # Sick (S1)
                    "S2", # Sicker (S2)
                    "D")  # Dead (D)

n_states <- length(v_names_states)   # number of health states 

### Tunnel inputs 
# Number of tunnels, note: in our example the number of tunnels is identical to the number of cycles
n_tunnel_size    <- n_cycles
# Vector with cycles for tunnels
v_cycles_tunnel  <- 1:n_tunnel_size
# Vector with names for tunnel states of Sick state
v_Sick_tunnel    <- paste("S1_", seq(1, n_tunnel_size), "Yr", sep = "")
# Create variables for model with tunnels
v_names_states_tunnels <- c("H", v_Sick_tunnel, "S", "D") # health state names
n_states_tunnels <- length(v_names_states_tunnels)         # number of health states

### Discounting factors 
d_c <- 0.03        # annual discount rate for costs 
d_e <- 0.03        # annual discount rate for QALYs

### Strategies 
v_names_str <- c("Standard of care",      # store the strategy names
                 "Strategy AB") 
n_str       <- length(v_names_str)        # number of strategies

## Within-cycle correction (WCC) using Simpson's 1/3 rule 
v_wcc  <- gen_wcc(n_cycles = n_cycles, method = "Simpson1/3") 

### Transition rates (annual), and hazard ratios (HRs) 
r_HS1  <- 0.15  # constant annual rate of becoming Sick when Healthy
r_S1H  <- 0.5   # constant annual rate of becoming Healthy when Sick
hr_S1  <- 3     # hazard ratio of death in Sick vs Healthy 
hr_S2  <- 10    # hazard ratio of death in Sicker vs Healthy 

### Effectiveness of treatment AB 
hr_S1S2_trtAB <- 0.6  # hazard ratio of becoming Sicker when Sick under treatment AB

# Weibull parameters for state-residence-dependent transition probability of 
# becoming Sicker when Sick conditional on surviving
r_S1S2_scale <- 0.08 # scale
r_S1S2_shape <- 1.1  # shape

## Age-dependent mortality rates 
lt_usa_2015 <- read.csv("HMD_USA_Mx_2015.csv")
# Extract age-specific all-cause mortality for ages in model time horizon
v_r_mort_by_age <- lt_usa_2015 %>% 
  dplyr::filter(Age >= n_age_init & Age < n_age_max) %>%
  dplyr::select(Total) %>%
  as.matrix() # anyone above 100 have the same mortality

### State rewards 
#### Costs 
c_H     <- 2000  # annual cost of being Healthy
c_S1    <- 4000  # annual cost of being Sick
c_S2    <- 15000 # annual cost of being Sicker
c_D     <- 0     # annual cost of being dead
c_trtAB <- 25000 # annual cost of receiving treatment AB
#### Utilities 
u_H     <- 1     # annual utility of being Healthy
u_S1    <- 0.75  # annual utility of being Sick
u_S2    <- 0.5   # annual utility of being Sicker
u_D     <- 0     # annual utility of being dead
u_trtAB <- 0.95  # annual utility when receiving treatment AB

### Transition rewards 
du_HS1 <- 0.01  # disutility when transitioning from Healthy to Sick
ic_HS1 <- 1000  # increase in cost when transitioning from Healthy to Sick
ic_D   <- 2000  # increase in cost when dying

### Discount weight for costs and effects 
v_dwc  <- 1 / ((1 + (d_e * cycle_length)) ^ (0:n_cycles))
v_dwe  <- 1 / ((1 + (d_c * cycle_length)) ^ (0:n_cycles))

# Process model inputs 
## Age-specific transition rates to the Dead state for all cycles 
v_r_HD_age <- rep(v_r_mort_by_age, each = 1/cycle_length)
# Name age-specific mortality vector 
names(v_r_HD_age) <- v_age_names

# compute mortality rates
v_r_S1D_age <- v_r_HD_age * hr_S1 # Age-specific mortality rate in the Sick state 
v_r_S2D_age <- v_r_HD_age * hr_S2 # Age-specific mortality rate in the Sicker state 

# transform rates to probabilities adjusting by cycle length
p_HS1      <- rate_to_prob(r = r_HS1,  t = cycle_length) # constant annual probability of becoming Sick when Healthy conditional on surviving 
p_S1H      <- rate_to_prob(r = r_S1H,  t = cycle_length) # constant annual probability of becoming Healthy when Sick conditional on surviving
v_p_HD_age  <- rate_to_prob(v_r_HD_age,  t = cycle_length) # Age-specific mortality risk in the Healthy state 
v_p_S1D_age <- rate_to_prob(v_r_S1D_age, t = cycle_length) # Age-specific mortality risk in the Sick state
v_p_S2D_age <- rate_to_prob(v_r_S2D_age, t = cycle_length) # Age-specific mortality risk in the Sicker state

## State-residence-dependent transition rate of becoming Sicker when Sick 
# Weibull transition rate
v_r_S1S2_tunnels <- (v_cycles_tunnel*r_S1S2_scale)^r_S1S2_shape - 
                    ((v_cycles_tunnel - 1)*r_S1S2_scale)^r_S1S2_shape
                            
## Weibull transition probability conditional on surviving adjusting by cycle length 
v_p_S1S2_tunnels <- rate_to_prob(v_r_S1S2_tunnels, t = cycle_length)

## State-residence-dependent transition rate of becoming Sicker when Sick under treatment AB 
# Apply hazard ratio to rate to obtain transition rate of becoming Sicker when Sick for treatment AB
v_r_S1S2_tunnels_trtAB <- v_r_S1S2_tunnels * hr_S1S2_trtAB
# Transform rate to probability to become Sicker when Sick under treatment AB 
# adjusting by cycle length conditional on surviving
v_p_S1S2_tunnels_trtAB <- rate_to_prob(r = v_r_S1S2_tunnels_trtAB, t = cycle_length)
```

# 04 Construct state-transition models

## 04.1 Initial state vector

```{r}
# All starting healthy
v_m_init_tunnels <- c(1, rep(0, n_tunnel_size), 0, 0) 
```

## 04.2 Initialize cohort traces with tunnels

```{r}
### Initialize cohort trace for state-residece dependent cSTM under SoC 
m_M_tunnels_SoC <- matrix(0, 
                          nrow     = (n_cycles + 1), ncol = n_states_tunnels, 
                          dimnames = list(0:n_cycles, v_names_states_tunnels))
# Store the initial state vector in the first row of the cohort trace
m_M_tunnels_SoC[1, ] <- v_m_init_tunnels

### Initialize cohort trace for strategy AB
# Structure and initial states are the same as for SoC
m_M_tunnels_strAB <- m_M_tunnels_SoC # Strategy AB
```

## 04.3 Create transition probability arrays

```{r}
## Create transition probability arrays for strategy SoC 
### Initialize transition probability array for strategy SoC 
# All transitions to a non-death state are assumed to be conditional on survival
a_P_tunnels_SoC <- array(0, 
                         dim = c(n_states_tunnels, n_states_tunnels, n_cycles),
                         dimnames = list(v_names_states_tunnels, 
                                         v_names_states_tunnels, 
                                         0:(n_cycles - 1)))
### Fill in array
## From H
a_P_tunnels_SoC["H", "H", ]              <- (1 - v_p_HD_age) * (1 - p_HS1)
a_P_tunnels_SoC["H", v_Sick_tunnel[1], ] <- (1 - v_p_HD_age) *      p_HS1
a_P_tunnels_SoC["H", "D", ]              <- v_p_HD_age
## From S1
for (i in 1:n_tunnel_size) {
  a_P_tunnels_SoC[v_Sick_tunnel[i], "H", ]  <- (1 - v_p_S1D_age) * p_S1H
  a_P_tunnels_SoC[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1D_age) * v_p_S1S2_tunnels[i]
  a_P_tunnels_SoC[v_Sick_tunnel[i], "D", ]  <-      v_p_S1D_age
  if (i == n_tunnel_size) {
    # If reaching last tunnel state, ensure that the cohort that does not
    # transition out of the Sick state, remain in the last Sick tunnel state
    a_P_tunnels_SoC[v_Sick_tunnel[i],
                    v_Sick_tunnel[i], ] <- (1 - v_p_S1D_age) *
      (1 - (p_S1H + v_p_S1S2_tunnels[i]))
  } else{
    a_P_tunnels_SoC[v_Sick_tunnel[i], 
                    v_Sick_tunnel[i + 1], ]   <- (1 - v_p_S1D_age) *
      (1 - (p_S1H + v_p_S1S2_tunnels[i]))
  }
}
## From S2
a_P_tunnels_SoC["S2", "S2", ] <- 1 - v_p_S2D_age
a_P_tunnels_SoC["S2", "D", ]  <-     v_p_S2D_age
## From D
a_P_tunnels_SoC["D", "D", ] <- 1

### Initialize transition probability array for strategy AB 
a_P_tunnels_strAB <- a_P_tunnels_SoC
# Update only transition probabilities from S1 involving v_p_S1S2_tunnels
for (i in 1:n_tunnel_size) {
  a_P_tunnels_strAB[v_Sick_tunnel[i], "H", ]  <- (1 - v_p_S1D_age) * p_S1H
  a_P_tunnels_strAB[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1D_age) * v_p_S1S2_tunnels_trtAB[i]
  a_P_tunnels_strAB[v_Sick_tunnel[i], "D", ]  <-      v_p_S1D_age
  if (i == n_tunnel_size) {
    # If reaching last tunnel state, ensure that the cohort that does not
    # transition out of the Sick state, remain in the last Sick tunnel state
    a_P_tunnels_strAB[v_Sick_tunnel[i],
                      v_Sick_tunnel[i], ] <- (1 - v_p_S1D_age) *
      (1 - (p_S1H + v_p_S1S2_tunnels_trtAB[i]))
  } else{
    a_P_tunnels_strAB[v_Sick_tunnel[i], 
                      v_Sick_tunnel[i + 1], ] <- (1 - v_p_S1D_age) *
      (1 - (p_S1H + v_p_S1S2_tunnels_trtAB[i]))
  }
}

## Check if transition probability arrays are valid 
### Check that transition probabilities are [0, 1] 
check_transition_probability(a_P_tunnels_SoC,   verbose = TRUE)
check_transition_probability(a_P_tunnels_strAB, verbose = TRUE)
### Check that all rows for each slice of the array sum to 1 
check_sum_of_transition_array(a_P_tunnels_SoC,   n_states = n_states_tunnels, n_cycles = n_cycles, verbose = TRUE)
check_sum_of_transition_array(a_P_tunnels_strAB, n_states = n_states_tunnels, n_cycles = n_cycles, verbose = TRUE)
```

## 04.4 Create transition dynamics arrays

```{r}
# These arrays will capture transitions from each state to another over time 
### Initialize transition dynamics array for strategy SoC 
a_A_tunnels_SoC <- array(0,
                     dim = c(n_states_tunnels, n_states_tunnels, n_cycles + 1),
                     dimnames = list(v_names_states_tunnels, v_names_states_tunnels, 0:n_cycles))
# Set first slice of A with the initial state vector in its diagonal
diag(a_A_tunnels_SoC[, , 1]) <- v_m_init_tunnels
### Initialize transition-dynamics array for strategy AB
# Structure and initial states are the same as for SoC
a_A_tunnels_strAB <- a_A_tunnels_SoC
```

# 05 Run Markov model

```{r}
# Iterative solution of state-residence dependent cSTM
for (t in 1:n_cycles) {
  ## Fill in cohort trace
  # For SoC
  m_M_tunnels_SoC[t + 1, ]   <- m_M_tunnels_SoC[t, ]   %*% a_P_tunnels_SoC[, , t]
  # For strategy AB
  m_M_tunnels_strAB[t + 1, ] <- m_M_tunnels_strAB[t, ] %*% a_P_tunnels_strAB[, , t]
  
  ## Fill in transition-dynamics array
  # For SoC
  a_A_tunnels_SoC[, , t + 1]   <- diag(m_M_tunnels_SoC[t, ])   %*% a_P_tunnels_SoC[, , t]
  # For strategy AB
  a_A_tunnels_strAB[, , t + 1] <- diag(m_M_tunnels_strAB[t, ]) %*% a_P_tunnels_strAB[, , t]
}

# Create aggregated trace
m_M_tunnels_SoC_sum   <- cbind(H  = m_M_tunnels_SoC[, "H"], 
                               S1 = rowSums(m_M_tunnels_SoC[, 2:(n_tunnel_size + 1)]), 
                               S2 = m_M_tunnels_SoC[, "S2"],
                               D  = m_M_tunnels_SoC[, "D"])
m_M_tunnels_strAB_sum <- cbind(H  = m_M_tunnels_strAB[, "H"], 
                               S1 = rowSums(m_M_tunnels_strAB[, 2:(n_tunnel_size + 1)]), 
                               S2 = m_M_tunnels_strAB[, "S2"],
                               D  = m_M_tunnels_strAB[, "D"])

## Store the cohort traces in a list 
l_m_M <- list(m_M_tunnels_SoC_sum,      
              m_M_tunnels_strAB_sum)
names(l_m_M) <- v_names_str

## Store the transition dynamics array for each strategy in a list 
l_a_A <- list(a_A_tunnels_SoC,
              a_A_tunnels_strAB)
names(l_a_A) <- v_names_str
```

# 06 Plot Outputs

## 06.1 Plot the cohort trace for strategies SoC and AB

```{r}
plot_trace(m_M_SoC)
plot_trace(m_M_strAB)
```

# 07 State Rewards 

```{r}
## Scale by the cycle length 
# Vector of utilities per cycle for S1 under strategy SoC
v_u_S1_SoC        <- rep(u_S1, n_tunnel_size)
names(v_u_S1_SoC) <- v_Sick_tunnel
# Vector of utilities under strategy SoC
v_u_SoC <- c(H  = u_H, 
             S1 = v_u_S1_SoC, 
             S2 = u_S2,
             D  = u_D) * cycle_length
# Vector of costs per cycle for S1 under strategy SoC
v_c_S1_SoC <- rep(c_S1, n_tunnel_size)
names(v_c_S1_SoC) <- v_Sick_tunnel
# Vector of costs per cycle under strategy SoC
v_c_SoC <- c(H  = c_H,
             S1 = v_c_S1_SoC, 
             S2 = c_S2,
             D  = c_D) * cycle_length

# Vector of utilities per cycle for S1 under strategy AB
v_u_S1_strAB        <- rep(u_trtAB, n_tunnel_size)
names(v_u_S1_strAB) <- v_Sick_tunnel
# Vector of  utilities under strategy AB
v_u_strAB <- c(H  = u_H, 
               S1 = v_u_S1_strAB, 
               S2 = u_S2, 
               D  = u_D) * cycle_length
# Vector of costs per cycle for S1 under strategy AB
v_c_S1_strAB        <- rep(c_S1 + c_trtAB, n_tunnel_size)
names(v_c_S1_strAB) <- v_Sick_tunnel
# Vector of costs per cycle under strategy AB
v_c_strAB <- c(H  = c_H, 
               S1 = v_c_S1_strAB, 
               S2 = c_S2 + c_trtAB, 
               D  = c_D) * cycle_length

## Store state rewards 
# Store the vectors of state utilities for each strategy in a list 
l_u   <- list(v_u_SoC,
              v_u_strAB)
# Store the vectors of state cost for each strategy in a list 
l_c   <- list(v_c_SoC,
              v_c_strAB)

# assign strategy names to matching items in the lists
names(l_u) <- names(l_c) <- v_names_str
```

# 08 Compute expected outcomes 

```{r}
# Create empty vectors to store total utilities and costs 
v_tot_qaly <- v_tot_cost <- vector(mode = "numeric", length = n_str)
names(v_tot_qaly) <- names(v_tot_cost) <- v_names_str

## Loop through each strategy and calculate total utilities and costs 
for (i in 1:n_str) { # i <- 1
  v_u_str         <- l_u[[i]]   # select the vector of state utilities for the i-th strategy
  v_c_str         <- l_c[[i]]   # select the vector of state costs for the i-th strategy
  a_A_tunnels_str <- l_a_A[[i]] # select the transition array for the i-th strategy
  
  ## Array of state rewards 
  # Create transition matrices of state utilities and state costs for the i-th strategy
  m_u_str   <- matrix(v_u_str, nrow = n_states_tunnels, ncol = n_states_tunnels, byrow = T)
  m_c_str   <- matrix(v_c_str, nrow = n_states_tunnels, ncol = n_states_tunnels, byrow = T)
  # Expand the transition matrix of state utilities across cycles to form a transition array of state utilities
  a_R_u_str <- array(m_u_str, 
                     dim      = c(n_states_tunnels, n_states_tunnels, n_cycles + 1),
                     dimnames = list(v_names_states_tunnels, v_names_states_tunnels, 0:n_cycles))
  # Expand the transition matrix of state costs across cycles to form a transition array of state costs
  a_R_c_str <- array(m_c_str, 
                     dim      = c(n_states_tunnels, n_states_tunnels, n_cycles + 1),
                     dimnames = list(v_names_states_tunnels, v_names_states_tunnels, 0:n_cycles))
  
  ## Apply transition rewards
  # Apply disutility due to transition from H to S1
  a_R_u_str["H", "S1_1Yr", ]          <- a_R_u_str["H", "S1_1Yr", ]          - du_HS1
  # Add transition cost per cycle due to transition from H to S1
  a_R_c_str["H", "S1_1Yr", ]          <- a_R_c_str["H", "S1_1Yr", ]          + ic_HS1
  # Add transition cost  per cycle of dying from all non-dead states
  a_R_c_str[-n_states_tunnels, "D", ] <- a_R_c_str[-n_states_tunnels, "D", ] + ic_D
  
  ### Expected QALYs and costs for all transitions per cycle
  # QALYs = life years x QoL
  # Note: all parameters are annual in our example. In case your own case example is different make sure you correctly apply.
  a_Y_c_str <- a_A_tunnels_str * a_R_c_str
  a_Y_u_str <- a_A_tunnels_str * a_R_u_str 
  
  ### Expected QALYs and costs per cycle
  ## Vector of QALYs and costs
  v_qaly_str <- apply(a_Y_u_str, 3, sum) # sum the proportion of the cohort across transitions 
  v_cost_str <- apply(a_Y_c_str, 3, sum) # sum the proportion of the cohort across transitions
  
  ## Discounted total expected QALYs and Costs per strategy and apply within-cycle correction if applicable
  # QALYs
  v_tot_qaly[i] <- t(v_qaly_str) %*% (v_dwe * v_wcc)
  # Costs
  v_tot_cost[i] <- t(v_cost_str) %*% (v_dwc * v_wcc)
}
```

# 09 Cost-effectiveness analysis (CEA) 

```{r}
## Incremental cost-effectiveness ratios (ICERs) 
df_cea <- calculate_icers(cost       = v_tot_cost, 
                          effect     = v_tot_qaly,
                          strategies = v_names_str)
df_cea
```

```{r}
## CEA table in proper format 
table_cea <- format_table_cea(df_cea) 
table_cea
```

```{r}
## CEA frontier 
plot_icers(df_cea, label = "all", txtsize = 16) +
  expand_limits(x = max(table_cea$QALYs) + 0.1) +
  theme(legend.position = c(0.8, 0.3))
```

